{%- assign progress_bar = shop.metaobjects['progress_bar']['bundle'] -%}

{%- if progress_bar != blank -%}
  {%- liquid
    assign items = progress_bar.items.value
    assign calculated_total_price = 0

    for line_item in cart.items
      assign calculated_total_price = calculated_total_price | plus: line_item.final_line_price
    endfor

    assign total_cart_discount = 0
    assign all_total_cart_discount = 0

    for discount_application in cart.cart_level_discount_applications
      assign total_cart_discount = total_cart_discount | plus: discount_application.total_allocated_amount
    endfor

    if cart.total_price != cart.original_total_price
      assign all_total_cart_discount = cart.original_total_price | minus: cart.total_price
    endif

    assign calculated_total_price = calculated_total_price | minus: total_cart_discount
  -%}
{%- endif -%}

<div x-data="progressBar('{{ data }}')" x-init="init()" class="b-progress-bar__wrapper">
  <div class="b-progress-bar__unlock-text text-black">
    <span x-text="unlockText"></span>
  </div>

  <div class="b-progress-bar">
    <div class="b-progress-bar__block" :style="`--progress: ${progress}`">
      <div class="b-progress-bar__points">
        <template x-for="(point, index) in points" :key="index">
          <div
            class="b-progress-bar__point"
            :class="{ active: currentPrice >= parseFloat(point.minimum_subtotal.amount || 0) }"
            :style="`left: calc(${point.percent}% - 25px)`">
          </div>
        </template>
      </div>
      <span class="b-progress-bar__progress"></span>
    </div>
  </div>

  <div class="b-progress-bar__lock-text text-black">
    <span x-text="lockText"></span>
  </div>
</div>

<script>
  document.addEventListener('alpine:init', () => {
    Alpine.data('progressBar', (type) => ({
      // SAFE defaults з Liquid:
      {% if items == blank %}
        items: [],
      {% else %}
        items: {{ items | json }},
      {% endif %}
      success_text: {{ progress_bar.success_text | default: '' | json }},
      // стартова сума з Liquid (без cart-level знижок)
      initialCurrent: {{ calculated_total_price | default: 0 }},
      currency: {{ cart.currency.symbol | json }},

      // state
      points: [],
      currentPrice: 0,
      progress: 0,
      unlockText: '',
      lockText: '',
      type,

      init() {
        // гарантії типів
        if (!Array.isArray(this.items)) this.items = [];
        if (typeof this.initialCurrent !== 'number') this.initialCurrent = 0;

        // початкове значення (до готовності store)
        this.currentPrice = this.initialCurrent;

        this.calculatePoints();

        // підписки на зміни тоталу
        if (this.type === 'cart') {
          this.$nextTick(() => {
            const cartStore = Alpine.store('cart');
            if (cartStore) {
              // одразу підхопимо актуальне значення, якщо є
              if (typeof cartStore.totalPrice === 'number') {
                this.currentPrice = cartStore.totalPrice;
              }
              this.$watch('$store.cart.totalPrice', (newTotal) => {
                const n = Number(newTotal || 0);
                if (!Number.isNaN(n)) {
                  this.currentPrice = n;
                  this.updateProgressBar();
                }
              });
            }
            this.updateProgressBar();
          });
        } else if (this.type === 'bundle') {
          this.$nextTick(() => {
            const bundle = Alpine.store('bundlePDP');
            if (bundle && typeof bundle.bundleItemsTotal === 'number') {
              this.currentPrice = bundle.bundleItemsTotal;
            }
            this.$watch('$store.bundlePDP.bundleItemsTotal', (newTotal) => {
              const n = Number(newTotal || 0);
              if (!Number.isNaN(n)) {
                this.currentPrice = n;
                this.updateProgressBar();
              }
            });
            this.updateProgressBar();
          });
        } else {
          // невідомий тип — просто порахуємо з initialCurrent
          this.updateProgressBar();
        }
      },

      calculatePoints() {
        if (!Array.isArray(this.items) || this.items.length === 0) {
          this.points = [];
          return;
        }

        const amounts = this.items
          .map(it => parseFloat((it?.minimum_subtotal?.amount) ?? '0'))
          .filter(n => !Number.isNaN(n));

        const maxAmount = Math.max(0, ...amounts);
        // уникнемо ділення на 0
        const denom = maxAmount > 0 ? maxAmount : 1;

        this.points = this.items.map(it => {
          const amount = parseFloat((it?.minimum_subtotal?.amount) ?? '0');
          const percent = (amount / denom) * 100;
          return { ...it, percent: Number.isFinite(percent) ? percent.toFixed(2) : '0' };
        });
      },

      updateProgressBar() {
        // якщо немає точок — просто скидаємо тексти і прогрес
        if (!Array.isArray(this.items) || this.items.length === 0) {
          this.progress = 0;
          this.unlockText = '';
          this.lockText = '';
          return;
        }

        const cartTotal = Number(this.currentPrice || 0);

        // знаходимо наступний поріг
        const thresholds = this.items
          .map(it => ({
            raw: it,
            amount: parseFloat((it?.minimum_subtotal?.amount) ?? '0')
          }))
          .filter(o => !Number.isNaN(o.amount))
          .sort((a, b) => a.amount - b.amount);

        if (thresholds.length === 0) {
          this.progress = 0;
          this.unlockText = '';
          this.lockText = '';
          return;
        }

        const last = thresholds[thresholds.length - 1].amount;
        const denom = last > 0 ? last : 1;
        // progress як 0..1 (string у CSS не обов’язковий)
        this.progress = Math.min((cartTotal / denom), 1);

        // наступний ще не досягнутий
        const nextStage = thresholds.find(t => cartTotal < t.amount);

        if (!nextStage) {
          // досягнуто максимум
          this.unlockText = this.success_text || '';
          this.lockText = '';
        } else {
          const left = Math.max(0, nextStage.amount - cartTotal);
          const leftMoney = this.currency + (left / 100).toFixed(2);
          const unlock = nextStage.raw?.unlock_text || '';
          const base = nextStage.raw?.text || '';
          this.unlockText = unlock;
          this.lockText = base.replace('[value]', leftMoney);
        }
      },
    }));
  });
</script>
