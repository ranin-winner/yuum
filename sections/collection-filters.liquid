{% comment %}
  Collection Filters (Links + Tags)
  - Left: manual list of links (blocks)
  - Right: tag chips sourced from textarea setting
  - Filters ALL .product-card[data-tags] across the page
  - Persists selection via localStorage + URL (?tags=a,b,c)
  - Tailwind first; a tiny bit of SCSS optional below
{% endcomment %}

<section
  id="collection-filters-{{ section.id }}"
  class="collection-filters palette-{{ section.settings.color_scheme }} py-8 md:py-10"
  x-data="collectionFilters({
    storageKey: 'collection_filters_v1',
    pageKey: '{{ request.path | default: request.url }}',
    rawTags: `{{ section.settings.tags_source | escape }}`,
  })"
  x-init="init()"
>
  <div class="container">
    <div class="grid grid-cols-1 md:grid-cols-2  gap-[20px] md:gap-10 mb-[60px]">
      {%- comment -%} LEFT: manual link list {%- endcomment -%}
      <aside>
        {% comment %} {% if section.settings.left_title != blank %}
          <h3 class="text-lg md:text-xl font-medium">{{ section.settings.left_title }}</h3>
        {% endif %} {% endcomment %}
        <div class="md:pb-[24px] pb-[16px]">
            {%- render 'breadcrumbs', padding_top: 0, padding_bottom: 0, separator: '|' -%}
        </div>

        <nav
        class="collection-filters__colection-list swiper md:!overflow-visible"
        x-ref="linksSwiper"
      >
        <div class="swiper-wrapper md:flex md:flex-wrap md:gap-[8px]">
          {%- for block in section.blocks -%}
            {%- assign label = block.settings.display_text | default: 'Link' -%}
            {%- assign url   = block.settings.manual_url | default: routes.root_url -%}

            {%- comment -%} нормалізуємо шлях без домену/параметрів/якоря {%- endcomment -%}
            {%- assign link_path = url
              | remove: shop.url
              | remove: shop.secure_url
              | split: '?' | first
              | split: '#' | first
            -%}
            {%- assign link_path_slash = link_path | append: '/' -%}

            {%- assign is_active = false -%}
            {%- if request.path == link_path or request.path == link_path_slash -%}
              {%- assign is_active = true -%}
            {%- endif -%}

            <div class="swiper-slide !w-auto md:!w-auto">
              <a
                href="{{ url }}"
                class="inline-flex items-center rounded-full px-[14px] py-[8px] md:px-[24px] md:py-[12px] md:text-[18px] text-[13px] border border-[#ADAEB0] hover:bg-white hover:text-[#474747] transition {% if is_active %}bg-white text-[#474747]{% else %}bg-[#E7E7E7] text-[#474747]{% endif %}"
                x-on:click="persistBeforeNavigate($event)"
                {{ block.shopify_attributes }}
              >
                {{ label }}
              </a>
            </div>
          {%- endfor -%}
        </div>
      </nav>

      </aside>

      {%- comment -%} RIGHT: tag chips + clear {%- endcomment -%}
      <div class="text-start md:text-end">
        <div class="pb-[16px] md:pb-[24px]">
            <span class="breadcrumb-link breadcrumb-link--tag">Tags</span>
        </div>


        <div class="flex flex-wrap gap-2 md:justify-end" aria-label="Tags">
          <!-- chips -->
          <template x-for="tag in visibleTags" :key="tag">
            <button
              type="button"
              class="chip inline-flex items-center gap-2 rounded-full border border-[#ADAEB0] transition
                      text-[13px] px-[10px] py-[6px] md:px-[12px] md:py-[8px] hover:bg-white hover:text-[#474747]"
              :class="isSelected(tag) ? 'bg-white text-[#474747]' : 'bg-[#E7E7E7] text-[#474747]'"
              @click="toggle(tag)"
              x-text="tag"
            ></button>
          </template>

          <!-- Clear all as last chip, only when any selected -->
          <template x-if="selected.length">
            <button
              type="button"
              class="chip inline-flex items-center rounded-full border border-black/15 px-3 py-1.5 text-[13px] text-[#474747] bg-white "
              @click="clearAll()"
            >
              Clear all
            </button>
          </template>
        </div>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('alpine:init', () => {
      Alpine.data('collectionFilters', (opts) => ({
        storageKey: opts.storageKey,
        pageKey: opts.pageKey,
        rawTags: opts.rawTags,

        allTags: [],
        visibleTags: [],
        selected: [],

        // mobile swiper (<600px) for .collection-filters__colection-list
        linksSwiper: null,
        linksSwiperMM: null,

        init() {
          document.documentElement.classList.remove('hidden');

          this.allTags = this.parseTags(this.rawTags);
          this.visibleTags = this.allTags;

          const fromUrl = this.readTagsFromUrl();
          const fromLs  = this.readFromStorage();
          this.selected = fromUrl.length ? fromUrl : fromLs;

          // init/destroy swiper depending on viewport
          this.linksSwiperMM = window.matchMedia('(max-width: 600px)');
          const applyMM = (e) => (e.matches ? this.enableLinksSwiper() : this.disableLinksSwiper());
          applyMM(this.linksSwiperMM);
          if (this.linksSwiperMM.addEventListener) {
            this.linksSwiperMM.addEventListener('change', applyMM);
          } else {
            this.linksSwiperMM.addListener(applyMM); // older Safari
          }

          this.$nextTick(() => {
            this.apply();
          });
        },

        enableLinksSwiper() {
          if (this.linksSwiper || !this.$refs.linksSwiper) return;
          // Swiper is expected to be globally available
          this.linksSwiper = new Swiper(this.$refs.linksSwiper, {
            slidesPerView: 'auto',
            spaceBetween: 8,
            freeMode: true,
            watchOverflow: true,
          });
        },
        disableLinksSwiper() {
          if (!this.linksSwiper) return;
          this.linksSwiper.destroy(true, true);
          this.linksSwiper = null;
        },

        // utils
        parseTags(str) {
          if (!str) return [];
          return str
            .split(/[\n,;]+/g)
            .map(s => s.trim().toLowerCase())
            .filter(Boolean)
            .filter((v, i, a) => a.indexOf(v) === i);
        },
        isSelected(tag) {
          return this.selected.includes(tag);
        },

        // selection
        toggle(tag) {
          const i = this.selected.indexOf(tag);
          if (i === -1) this.selected.push(tag);
          else this.selected.splice(i, 1);
          this.apply();
        },
        clearAll() {
          this.selected = [];
          this.apply();
        },

        // persistence
        persistBeforeNavigate(e) {
          this.writeToStorage();
          const url = new URL(e.currentTarget.href, window.location.origin);
          if (this.selected.length) url.searchParams.set('tags', this.selected.join(','));
          else url.searchParams.delete('tags');
          e.currentTarget.href = url.toString();
        },
        readFromStorage() {
          try {
            const raw = localStorage.getItem(this.storageKey);
            if (!raw) return [];
            const all = JSON.parse(raw);
            return Array.isArray(all?.global) ? all.global : [];
          } catch (_) {
            return [];
          }
        },
        writeToStorage() {
          try {
            localStorage.setItem(this.storageKey, JSON.stringify({ global: this.selected }));
          } catch (_) {}
        },
        readTagsFromUrl() {
          const sp = new URLSearchParams(window.location.search);
          const q = sp.get('tags');
          if (!q) return [];
          return q.split(',').map(s => s.trim().toLowerCase()).filter(Boolean);
        },
        updateQueryParam() {
          const sp = new URLSearchParams(window.location.search);
          if (this.selected.length) sp.set('tags', this.selected.join(','));
          else sp.delete('tags');
          const newUrl = `${window.location.pathname}?${sp.toString()}${window.location.hash || ''}`.replace(/\?$/, '');
          history.replaceState({}, '', newUrl);
        },

        // helpers for finding cards & wrappers reliably
        getCardsInSection(sectionEl) {
          return sectionEl.querySelectorAll('.product-card[data-tags]');
        },
        getWrapperForCard(cardEl) {
          return cardEl.closest('.grid > *') || cardEl.parentElement;
        },

        // core
        apply() {
          const selected = this.selected.map(t => t.toLowerCase());
          const sections = document.querySelectorAll('.collection-grid');

          sections.forEach(sectionEl => {
            const cards = this.getCardsInSection(sectionEl);

            cards.forEach(card => {
              const wrapper = this.getWrapperForCard(card);
              if (!wrapper) {
                console.warn('Wrapper not found for card:', card);
                return;
              }

              const tagsAttr = (card.dataset.tags || card.getAttribute('data-tags') || '').toLowerCase();
              const productTags = tagsAttr.split(/[\s,;]+/g).filter(Boolean);

              const match = !selected.length || selected.every(t => productTags.includes(t));

              if (match) {
                wrapper.classList.remove('hidden');
              } else {
                wrapper.classList.add('hidden');
              }
            });
          });

          this.writeToStorage();
          this.updateQueryParam();
        },
      }));
    });
  </script>



</section>

{% schema %}
{
  "name": "Collection Filters",
  "settings": [
    {
      "type": "textarea",
      "id": "tags_source",
      "label": "Tags available for filtering",
      "info": "List of tags separated by commas, semicolons, or new lines. Ex: sweet, sour, bitter",
      "default": "sweet, sour, bitter, salt, umami, chilled, frozen, vegetarian, gluten free, japan, brazil"
    }
  ],
  "blocks": [
    {
      "type": "link_item",
      "name": "Link item",
      "settings": [
        { "type": "text", "id": "display_text", "label": "Display text (optional)" },
        { "type": "url", "id": "manual_url", "label": "Link to page/collection", "default": "/" }
      ]
    }
  ],
  "max_blocks": 16,
  "presets": [
    { "name": "Collection Filters" }
  ]
}
{% endschema %}
