<!doctype html>
<html class="no-js antialiased scroll-smooth" lang="{{ request.locale.iso_code }}">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <link rel="canonical" href="{{ canonical_url }}">

    {% if shop.brand.logo != blank %}
      <link rel="icon" type="image/png" href="{{ shop.brand.logo | image_url: width: 32, height: 32 }}">
    {% endif %}

    <title>{{ page_title }}</title>

    {% if page_description %}
      <meta name="description" content="{{ page_description | escape }}">
    {% endif %}
    <style>
      /* todo: 1) move this to a separate scss file but with imported settings */
      /* todo: 2) think about what exact variables are needed for the theme */
      {% for scheme in settings.color_schemes %}
        .palette-{{ scheme }} {
          --theme-color-bg: {{ scheme.settings.background }};
          --theme-color-primary: {{ scheme.settings.color_primary }};
          --theme-color-secondary: {{ scheme.settings.color_secondary }};
          --theme-color-tertiary: {{ scheme.settings.color_tertiary }};
        }

        .palette-{{ scheme }} .btn.btn-scheme {
          background-color: var(--theme-color-primary);
          border-color: var(--theme-color-primary);
          color: white;
        }

        .palette-{{ scheme }} .btn.btn-scheme:hover {
          background-color: var(--theme-color-tertiary);
          color: var(--theme-color-primary);
        }
      {% endfor %}
    </style>
    <style>
      [x-cloak] {
        display: none !important;
      }
    </style>
    <script>
      window.shopUrl = '{{ request.origin }}';
      window.routes = {
        cart_add_url: '{{ routes.cart_add_url }}',
        cart_change_url: '{{ routes.cart_change_url }}',
        cart_update_url: '{{ routes.cart_update_url }}',
        cart_url: '{{ routes.cart_url }}',
        predictive_search_url: '{{ routes.predictive_search_url }}',
        product_recommendations_url: '{{ routes.product_recommendations_url }}',
      };

      document.documentElement.className = document.documentElement.className.replace('no-js', 'js');
    </script>


    {% render 'typography' %}



    {% render 'entry' with 'main.theme.js' %}
    {% render 'entry' with 'main.scss', preload_stylesheet: true %}


    {% if template contains 'collection' %}
      {% comment %} {% render 'entry' with 'theme.collection.js' %} {% endcomment %}
    {% elsif template contains 'product' %}
      {% render 'entry' with 'page-pdp.scss' %}
    {% else %}
      {% comment %} {% render 'entry' with 'entry.theme.js' %} {% endcomment %}
    {% endif %}

    {{ content_for_header }}
    {% render 'custom-fonts' %}

    {%- comment -%} Smooth scroll (Lenis) {%- endcomment -%}
    <script src="https://cdn.jsdelivr.net/npm/@studio-freight/lenis@1.1.19/dist/lenis.min.js"></script>

    {%- comment -%} GSAP + ScrollTrigger {%- endcomment -%}
    <script src="https://cdn.jsdelivr.net/npm/gsap@3/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3/dist/ScrollTrigger.min.js"></script>

    <link href="https://api.mapbox.com/mapbox-gl-js/v3.16.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.16.0/mapbox-gl.js"></script>

    <script>
      document.addEventListener('DOMContentLoaded', function() {
        setInterval(function() {
          const cartIsOpen = document.querySelector('.b-mini_cart.is-open');

          if (cartIsOpen) {
            document.addEventListener('wheel', blockAllScroll, { passive: false });
            document.addEventListener('touchmove', blockAllScroll, { passive: false });

            const cartItems = document.querySelector('.b-mini_cart-items');
            if (cartItems) {
              cartItems.addEventListener('wheel', allowCartItemsScroll, { passive: false });
              cartItems.addEventListener('touchmove', allowCartItemsScroll, { passive: false });
            }

          } else {
            document.removeEventListener('wheel', blockAllScroll);
            document.removeEventListener('touchmove', blockAllScroll);

            const cartItems = document.querySelector('.b-mini_cart-items');
            if (cartItems) {
              cartItems.removeEventListener('wheel', allowCartItemsScroll);
              cartItems.removeEventListener('touchmove', allowCartItemsScroll);
            }
          }
        }, 100);

        function blockAllScroll(e) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }

        function allowCartItemsScroll(e) {
          e.stopPropagation(); // Не даємо події дійти до document
        }
      });
    </script>
  </head>

  {%- assign transparent_pages = 'about-product-mochi,contact,catering,vacancies,wholesale,about-us-new' | split: ',' -%}
  {%- assign current_page_handle = page.handle | default: '' -%}
  {%- assign template_suffix = template.suffix | default: '' -%}

  <body
    x-data
    :class="$store.shopMainStore.body_no_scroll ? 'no-scroll' : ''"
    class="min-h-svh template-{{ template.name }} m-{{ template | replace: '.', '-' }}{% for page_handle in transparent_pages %}{% if page_handle == current_page_handle or page_handle == template_suffix %} transparent-header{% break %}{% endif %}{% endfor %}"
  >

    <div id="l-main">
      <header
        id="id_header"
        class="
          top-0
          z-50
          b-header
        ">
        {% include 'header' %}
        {% render 'search-modal' %}
      </header>
      <main
        id="MainContent"
        class="flex flex-col outline-none max-w-full"
        tabindex="-1">
        {{ content_for_layout }}
      </main>
      <footer>
        {% comment %} {{ powered_by_link }} {% endcomment %}
        {% include 'footer' %}
      </footer>
      <div class="l-overlay"></div>
      {% render 'mini-cart' %}

      {% render 'customer-auth-modal' %}
    </div>
  </body>

  <script>
    (function() {
      const HEADER_SELECTOR = '.b-header'; // заміни на свій, якщо потрібно (наприклад, '.b-header')
      const HERO_SELECTOR = '.b-hero-banner';
      const HERO_FIRST_CLASS = 'hero--is-first';

      const header = document.querySelector(HEADER_SELECTOR);
      if (!header) return;

      // 1) Знаходимо ПЕРШУ видиму контентну секцію після хедера
      const sections = document.querySelectorAll('.shopify-section');
      let firstSection = null;
      for (const sec of sections) {
        const visible = sec.offsetParent !== null || getComputedStyle(sec).display !== 'none';
        if (visible && sec.childElementCount > 0) {
          firstSection = sec;
          break;
        }
      }
      if (!firstSection) return;

      // 2) Перевіряємо, чи в першій секції є hero
      //    ВАЖЛИВО: клас додаємо ЛИШЕ на цей конкретний hero у першій секції
      const firstHero = firstSection.querySelector(HERO_SELECTOR);
      if (!firstHero) {
        // якщо перша секція не hero — гарантуємо сірий стан, і все
        header.classList.remove('header--over-hero');
        return;
      }

      // 2.1) Позначаємо цей hero як "перший"
      firstHero.classList.add(HERO_FIRST_CLASS);

      // 3) Логіка перемикання стану хедера (залишена, як просив)
      function setupObserver() {
        const headerH = header.offsetHeight || 80;

        // Початковий стан (на випадок перезавантаження не з самого верху)
        header.classList.toggle('header--over-hero', firstHero.getBoundingClientRect().top < headerH);

        const io = new IntersectionObserver(([entry]) => {
          if (entry.isIntersecting) {
            header.classList.add('header--over-hero');   // білий (поверх hero)
          } else {
            header.classList.remove('header--over-hero'); // сірий
          }
        }, {
          root: null,
          rootMargin: `-${headerH}px 0px 0px 0px`,
          threshold: 0
        });

        io.observe(firstHero);

        // Перебудова при зміні розмірів (висота хедера/ресайз)
        window.addEventListener('resize', debounce(() => {
          io.disconnect();
          setupObserver();
        }, 200));
      }

      function debounce(fn, ms) {
        let t;
        return function() { clearTimeout(t); t = setTimeout(fn, ms); };
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', setupObserver);
      } else {
        setupObserver();
      }
    })();
  </script>

</html>


