{% comment %}
  Collection Filters (Links + Tags)
  - Left: manual list of links (blocks)
  - Right: tag chips sourced from textarea setting
  - Filters ALL .product-card[data-tags] across the page
  - Persists selection via localStorage + URL (?tags=a,b,c)
  - Tailwind first; a tiny bit of SCSS optional below
{% endcomment %}

<section
  id="collection-filters-{{ section.id }}"
  class="collection-filters palette-{{ section.settings.color_scheme }} py-6 md:py-10"
  x-data="collectionFilters({
    storageKey: 'collection_filters_v1',
    pageKey: '{{ request.path | default: request.url }}',
    rawTags: `{{ section.settings.tags_source | escape }}`,
  })"
  x-init="init()"
>
  <div class="container">
    <div class="grid grid-cols-1 md:grid-cols-[260px_minmax(0,1fr)] gap-6 md:gap-10">
      {%- comment -%} LEFT: manual link list {%- endcomment -%}
      <aside class="space-y-3">
        {% if section.settings.left_title != blank %}
          <h3 class="text-lg md:text-xl font-medium">{{ section.settings.left_title }}</h3>
        {% endif %}

        <nav class="flex md:block gap-2 md:gap-3 flex-wrap">
          {%- for block in section.blocks -%}
            {%- assign label = block.settings.display_text | default: 'Link' -%}
            {%- assign url   = block.settings.manual_url | default: routes.root_url -%}

            {%- comment -%} Нормалізуємо шлях без домену/параметрів/якорів {%- endcomment -%}
            {%- assign link_path = url
            | remove: shop.url
            | remove: shop.secure_url
            | split: '?' | first
            | split: '#' | first
            -%}
            {%- assign link_path_slash = link_path | append: '/' -%}

            {%- assign is_active = false -%}
            {%- if request.path == link_path or request.path == link_path_slash -%}
                {%- assign is_active = true -%}
            {%- endif -%}

            <a
            href="{{ url }}"
            class="inline-flex items-center rounded-full px-4 py-2 text-sm border border-black/10 hover:border-black/40 transition {% if is_active %}bg-black text-white{% else %}bg-white text-black{% endif %}"
            x-on:click="persistBeforeNavigate($event)"
            {{ block.shopify_attributes }}
            >
                {{ label }}
            </a>

          {%- endfor -%}
        </nav>

        {% if section.settings.show_hint %}
          <p class="text-xs text-black/50 mt-2">Порада: ліві пункти — це звичайні лінки. Обрані теги збережуться між сторінками, доки не натиснути “Clear all”.</p>
        {% endif %}
      </aside>

      {%- comment -%} RIGHT: tag chips + clear {%- endcomment -%}
      <div>
        {% if section.settings.right_title != blank %}
          <div class="flex items-center justify-between mb-3">
            <h3 class="text-lg md:text-xl font-medium">{{ section.settings.right_title }}</h3>
            <template x-if="selected.length">
              <button type="button" class="text-sm underline" @click="clearAll()">Clear all</button>
            </template>
          </div>
        {% endif %}

        <div class="flex flex-wrap gap-2" aria-label="Tags">
          <!-- chips -->
          <template x-for="tag in visibleTags" :key="tag">
            <button
              type="button"
              class="chip inline-flex items-center gap-2 rounded-full border border-black/15 px-3 py-1.5 text-sm transition
                     hover:border-black/40"
              :class="isSelected(tag) ? 'bg-black text-white' : 'bg-white text-black'"
              @click="toggle(tag)"
              x-text="tag"
            ></button>
          </template>

          <!-- Clear all as last chip, only when any selected -->
          <template x-if="selected.length">
            <button
              type="button"
              class="chip inline-flex items-center rounded-full border border-black/15 px-3 py-1.5 text-sm bg-white hover:border-black/40"
              @click="clearAll()"
            >
              Clear all
            </button>
          </template>
        </div>

        {% if section.settings.note != blank %}
          <p class="text-xs text-black/50 mt-3">{{ section.settings.note }}</p>
        {% endif %}
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('alpine:init', () => {
      Alpine.data('collectionFilters', (opts) => ({
        storageKey: opts.storageKey,
        pageKey: opts.pageKey,
        rawTags: opts.rawTags,
        allTags: [],
        visibleTags: [],
        selected: [],
  
        init() {
          this.allTags = this.parseTags(this.rawTags)
          this.visibleTags = this.allTags
  
          const fromUrl = this.readTagsFromUrl()
          const fromLs  = this.readFromStorage()
          this.selected = fromUrl.length ? fromUrl : fromLs
  
          this.apply()
        },
  
        // ---- utils
        parseTags(str) {
          if (!str) return []
          return str
            .split(/[\n,;]+/g)
            .map(s => s.trim().toLowerCase())
            .filter(Boolean)
            .filter((v, i, a) => a.indexOf(v) === i)
        },
        isSelected(tag) { return this.selected.includes(tag) },
  
        // ---- selection actions
        toggle(tag) {
          const i = this.selected.indexOf(tag)
          if (i === -1) this.selected.push(tag); else this.selected.splice(i, 1)
          this.apply()
        },
        clearAll() {
          this.selected = []
          this.apply()
        },
  
        // ---- persistence
        persistBeforeNavigate(e) {
          this.writeToStorage()
          const url = new URL(e.currentTarget.href, window.location.origin)
          if (this.selected.length) url.searchParams.set('tags', this.selected.join(','))
          else url.searchParams.delete('tags')
          e.currentTarget.href = url.toString()
        },
        readFromStorage() {
          try {
            const raw = localStorage.getItem(this.storageKey)
            if (!raw) return []
            const all = JSON.parse(raw)
            return Array.isArray(all?.global) ? all.global : []
          } catch(_) { return [] }
        },
        writeToStorage() {
          try { localStorage.setItem(this.storageKey, JSON.stringify({ global: this.selected })) } catch(_){}
        },
        readTagsFromUrl() {
          const sp = new URLSearchParams(window.location.search)
          const q = sp.get('tags')
          if (!q) return []
          return q.split(',').map(s => s.trim().toLowerCase()).filter(Boolean)
        },
        updateQueryParam() {
          const sp = new URLSearchParams(window.location.search)
          if (this.selected.length) sp.set('tags', this.selected.join(','))
          else sp.delete('tags')
          const url = `${window.location.pathname}?${sp.toString()}${window.location.hash || ''}`
          history.replaceState({}, '', url)
        },
  
        // ---- core filtering (scoped by .collection-grid)
        apply() {
          const selected = this.selected.map(t => t.toLowerCase())
          const grids = document.querySelectorAll('.collection-grid')
  
          // якщо тегів немає — показуємо все у кожній грід-секції
          if (!selected.length) {
            grids.forEach(grid => {
              grid.querySelectorAll('.product-card[data-tags]').forEach(card => {
                card.classList.remove('hidden')
              })
            })
            this.writeToStorage()
            this.updateQueryParam()
            return
          }
  
          grids.forEach(grid => {
            const cards = grid.querySelectorAll('.product-card[data-tags]')
            cards.forEach(card => {
              // читаємо з dataset (швидше) з fallback на getAttribute
              const tagsAttr = (card.dataset.tags || card.getAttribute('data-tags') || '').toLowerCase()
              // нормалізуємо: пробіли/коми/крапки з комою
              const productTags = tagsAttr.split(/[\s,;]+/g).filter(Boolean)
  
              // AND-режим: усі вибрані теги мають бути в продукті
              const match = selected.every(t => productTags.includes(t))
  
              // ------ щоб перейти на OR, заміни попередній рядок на:
              // const match = selected.some(t => productTags.includes(t))
  
              if (match) card.classList.remove('hidden')
              else card.classList.add('hidden')
            })
          })
  
          this.writeToStorage()
          this.updateQueryParam()
        },
      }))
    })
  </script>
  
</section>

{% schema %}
{
  "name": "Collection Filters",
  "settings": [
    { "type": "text", "id": "left_title", "label": "Left title", "default": "Collections" },
    { "type": "text", "id": "right_title", "label": "Right title", "default": "Tags" },
    {
      "type": "textarea",
      "id": "tags_source",
      "label": "Tags available for filtering",
      "info": "Список тегів через кому, крапку з комою або з нового рядка. Напр.: sweet, sour, bitter",
      "default": "sweet, sour, bitter, salt, umami, chilled, frozen, vegetarian, gluten free, japan, brazil"
    },
    { "type": "checkbox", "id": "show_hint", "label": "Show note under links", "default": false },
    { "type": "text", "id": "note", "label": "Small note under tags" },
    { "type": "color_scheme", "id": "color_scheme", "label": "Color scheme", "default": "background-1" }
  ],
  "blocks": [
    {
      "type": "link_item",
      "name": "Link item",
      "settings": [
        { "type": "text", "id": "display_text", "label": "Display text (optional)" },
        { "type": "url", "id": "manual_url", "label": "Link to page/collection", "default": "/" }
      ]
    }
  ],
  "max_blocks": 16,
  "presets": [
    { "name": "Collection Filters" }
  ]
}
{% endschema %}
